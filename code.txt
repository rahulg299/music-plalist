folder1: handlers
file1: playlist.go

    package handlers

import (
    "encoding/json"
    "net/http"
    "music-playlist-generator/models"
    "music-playlist-generator/utils"
)

func GetPlaylists(w http.ResponseWriter, r *http.Request) {
    playlists := []models.Playlist{
        {
            Name: "Top Hits",
            Songs: []models.Song{
                {Title: "Song 1", Artist: "Artist 1", Album: "Album 1"},
                {Title: "Song 2", Artist: "Artist 2", Album: "Album 2"},
            },
        },
    }
    utils.WriteJSONResponse(w, http.StatusOK, playlists)
}

func SavePlaylist(w http.ResponseWriter, r *http.Request) {
    var playlist models.Playlist
    if err := json.NewDecoder(r.Body).Decode(&playlist); err != nil {
        utils.WriteJSONResponse(w, http.StatusBadRequest, map[string]string{"error": "Invalid request body"})
        return
    }
    utils.WriteJSONResponse(w, http.StatusOK, map[string]string{"message": "Playlist saved successfully!"})
}

file2: trending.go
package handlers

package handlers

import (
    "net/http"
    "music-playlist-generator/services"
    "music-playlist-generator/utils"
)

func GetTrendingSongs(w http.ResponseWriter, r *http.Request) {
    songs, err := services.FetchTrendingSongs()
    if err != nil {
        utils.WriteJSONResponse(w, http.StatusInternalServerError, map[string]string{"error": err.Error()})
        return
    }
    utils.WriteJSONResponse(w, http.StatusOK, songs)
}

folder2:middleware
file:middleware.go

// middleware/middleware.go
package middleware

import (
    "log"
    "net/http"
    "strings"
    "time"
)

func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        log.Printf(
            "%s %s %s",
            r.Method,
            r.RequestURI,
            time.Since(start),
        )
    })
}

func JSONContentTypeMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Check if the path starts with /api using strings.HasPrefix instead of slice
        if strings.HasPrefix(r.URL.Path, "/api") {
            w.Header().Add("Content-Type", "application/json")
        }
        next.ServeHTTP(w, r)
    })
}


folder3: models
file:playlist.go

package models

// Song represents a song with its details
type Song struct {
	Title  string `json:"title"`
	Artist string `json:"artist"`
	Album  string `json:"album"`
}

// Playlist represents a playlist with a list of songs
type Playlist struct {
	Name  string `json:"name"`
	Songs []Song `json:"songs"`
}


folder4: services
file1: lyrics.go


package services

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type LyricsResponse struct {
	Lyrics string `json:"lyrics"`
}

func FetchLyrics(artist, title string) (string, error) {
	// Build API URL
	url := fmt.Sprintf("https://api.lyrics.ovh/v1/%s/%s", artist, title)

	// Make HTTP request
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("failed to fetch lyrics: %v", err)
	}
	defer resp.Body.Close()

	// Decode response
	var lyricsResp LyricsResponse
	if err := json.NewDecoder(resp.Body).Decode(&lyricsResp); err != nil {
		return "", fmt.Errorf("failed to decode lyrics: %v", err)
	}

	return lyricsResp.Lyrics, nil
}

file2:spotify.go

package services

import (
    "context"
    "fmt"
    "os"
    "github.com/zmb3/spotify/v2"
    spotifyauth "github.com/zmb3/spotify/v2/auth"
    "golang.org/x/oauth2/clientcredentials"
)

func FetchTrendingSongs() ([]spotify.FullTrack, error) {
    config := &clientcredentials.Config{
        ClientID:     os.Getenv("SPOTIFY_CLIENT_ID"),
        ClientSecret: os.Getenv("SPOTIFY_CLIENT_SECRET"),
        TokenURL:     spotifyauth.TokenURL,
    }

    ctx := context.Background()
    token, err := config.Token(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to get token: %v", err)
    }

    httpClient := spotifyauth.New().Client(ctx, token)
    client := spotify.New(httpClient)

    playlistID := spotify.ID("37i9dQZEVXbMDoHDwVN2tF")
    tracks, err := client.GetPlaylistTracks(ctx, playlistID)
    if err != nil {
        return nil, fmt.Errorf("failed to fetch tracks: %v", err)
    }

    var fullTracks []spotify.FullTrack
    for _, track := range tracks.Tracks {
        fullTracks = append(fullTracks, track.Track)
    }

    return fullTracks, nil
}


folder5: static
file1:index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music Playlist Generator</title>
  <link rel="stylesheet" href="static/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <div class="container">
    <!-- Header -->
    <header>
      <h1>Music Playlist Generator</h1>
      <p>Create and manage your music playlists with ease.</p>
    </header>

    <!-- Trending Songs Section -->
    <section id="trending-songs" class="card">
      <h2>Trending Songs</h2>
      <ul id="trending-list"></ul>
    </section>

    <!-- Save Playlist Form -->
    <section id="save-playlist" class="card">
      <h2>Save Playlist</h2>
      <form id="playlist-form">
        <input type="text" id="playlist-name" placeholder="Enter playlist name" required>
        <button type="submit">Save Playlist</button>
      </form>
    </section>

    <!-- Saved Playlists Section -->
    <section id="saved-playlists" class="card">
      <h2>Saved Playlists</h2>
      <ul id="playlist-list"></ul>
    </section>
  </div>

  <script src="static/script.js"></script>
</body>
</html>

file2:script.js

// Global variables for state management
let isLoading = false;

// Utility function for showing loading state
function setLoading(loading) {
    isLoading = loading;
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => {
        button.disabled = loading;
    });
}

// Utility function for showing notifications
function showNotification(message, isError = false) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `notification ${isError ? 'error' : 'success'}`;
    alertDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 25px;
        border-radius: 5px;
        color: white;
        background-color: ${isError ? '#ff4444' : '#44b544'};
        z-index: 1000;
        transition: opacity 0.3s ease;
    `;
    alertDiv.textContent = message;
    document.body.appendChild(alertDiv);

    // Remove notification after 3 seconds
    setTimeout(() => {
        alertDiv.style.opacity = '0';
        setTimeout(() => {
            document.body.removeChild(alertDiv);
        }, 300);
    }, 3000);
}

// Fetch trending songs from the API
async function fetchTrendingSongs() {
    try {
        setLoading(true);
        const response = await fetch('/api/trending');
        if (!response.ok) {
            throw new Error('Failed to fetch trending songs');
        }
        const songs = await response.json();
        
        const trendingList = document.getElementById('trending-list');
        trendingList.innerHTML = ''; // Clear existing list
        
        songs.forEach(song => {
            const li = document.createElement('li');
            const artistName = song.Artists && song.Artists[0] ? song.Artists[0].Name : 'Unknown Artist';
            li.textContent = `${song.Name} - ${artistName}`;
            
            // Add play button or other controls if needed
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'song-controls';
            // Add controls here if needed
            
            li.appendChild(controlsDiv);
            trendingList.appendChild(li);
        });
    } catch (error) {
        console.error('Error fetching trending songs:', error);
        showNotification('Failed to load trending songs', true);
    } finally {
        setLoading(false);
    }
}

// Fetch saved playlists from the API
async function fetchPlaylists() {
    try {
        setLoading(true);
        const response = await fetch('/api/playlists');
        if (!response.ok) {
            throw new Error('Failed to fetch playlists');
        }
        const playlists = await response.json();
        
        const playlistList = document.getElementById('playlist-list');
        playlistList.innerHTML = ''; // Clear existing list
        
        playlists.forEach(playlist => {
            const li = document.createElement('li');
            li.textContent = playlist.name || playlist; // Handle both object and string responses
            
            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Ã—';
            deleteButton.className = 'delete-playlist';
            deleteButton.onclick = () => deletePlaylist(playlist.id || playlist);
            
            li.appendChild(deleteButton);
            playlistList.appendChild(li);
        });
    } catch (error) {
        console.error('Error fetching playlists:', error);
        showNotification('Failed to load playlists', true);
    } finally {
        setLoading(false);
    }
}

// Save a new playlist
async function savePlaylist(name) {
    try {
        setLoading(true);
        const response = await fetch('/api/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name: name }),
        });
        
        if (!response.ok) {
            throw new Error('Failed to save playlist');
        }
        
        const result = await response.json();
        showNotification(result.message || 'Playlist saved successfully!');
        await fetchPlaylists(); // Refresh the playlist list
    } catch (error) {
        console.error('Error saving playlist:', error);
        showNotification('Failed to save playlist', true);
    } finally {
        setLoading(false);
    }
}

// Delete a playlist (if implemented on backend)
async function deletePlaylist(playlistId) {
    if (!confirm('Are you sure you want to delete this playlist?')) {
        return;
    }
    
    try {
        setLoading(true);
        const response = await fetch(`/api/playlists/${playlistId}`, {
            method: 'DELETE',
        });
        
        if (!response.ok) {
            throw new Error('Failed to delete playlist');
        }
        
        showNotification('Playlist deleted successfully!');
        await fetchPlaylists(); // Refresh the playlist list
    } catch (error) {
        console.error('Error deleting playlist:', error);
        showNotification('Failed to delete playlist', true);
    } finally {
        setLoading(false);
    }
}

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    // Load initial data
    fetchTrendingSongs();
    fetchPlaylists();
    
    // Setup form submission
    const playlistForm = document.getElementById('playlist-form');
    if (playlistForm) {
        playlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const nameInput = document.getElementById('playlist-name');
            const playlistName = nameInput.value.trim();
            
            if (!playlistName) {
                showNotification('Please enter a playlist name', true);
                return;
            }
            
            await savePlaylist(playlistName);
            nameInput.value = ''; // Clear the input
        });
    }
    
    // Optional: Add refresh buttons
    const refreshButtons = document.querySelectorAll('.refresh-button');
    refreshButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (button.dataset.target === 'trending') {
                fetchTrendingSongs();
            } else if (button.dataset.target === 'playlists') {
                fetchPlaylists();
            }
        });
    });
});

// Optional: Add keyboard shortcuts
document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + R to refresh both lists
    if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault();
        fetchTrendingSongs();
        fetchPlaylists();
    }
});


  file3:styles.css

  

  folder6:utils
  file :http.go

  package utils

import (
	"encoding/json"
	"net/http"
)

// WriteJSONResponse writes a JSON response to the client
func WriteJSONResponse(w http.ResponseWriter, statusCode int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(data)
}


file: .env

SPOTIFY_CLIENT_ID=y36f9c08693c241bca6ed0604fb1d5ac1
SPOTIFY_CLIENT_SECRET=181dd64b10b643f0966e01240c6f0fa9
REDIRECT_URL=http:/localhost:3090



file:go.mod

module music-playlist-generator

go 1.23.5

require (
	github.com/gorilla/mux v1.8.1
	github.com/joho/godotenv v1.5.1
	github.com/zmb3/spotify/v2 v2.4.3
	golang.org/x/oauth2 v0.0.0-20210810183815-faf39c7919d5
)

require (
	github.com/golang/protobuf v1.5.2 // indirect
	golang.org/x/net v0.23.0 // indirect
	google.golang.org/appengine v1.6.7 // indirect
	google.golang.org/protobuf v1.33.0 // indirect
)


file: main.go

package main

import (
    "fmt"
    "log"
    "net/http"
    "os"
    "github.com/gorilla/mux"
    "github.com/joho/godotenv"
    "music-playlist-generator/handlers"
    "music-playlist-generator/middleware"
)

func main() {
    // Load environment variables
    err := godotenv.Load()
    if err != nil {
        log.Printf("No .env file found: %v", err)
    }

    // Initialize router
    r := mux.NewRouter()

    // Add middleware
    r.Use(middleware.LoggingMiddleware)
    r.Use(middleware.JSONContentTypeMiddleware)

    // Serve static files
    fs := http.FileServer(http.Dir("static"))
    r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", fs))

    // API routes
    api := r.PathPrefix("/api").Subrouter()
    api.HandleFunc("/playlists", handlers.GetPlaylists).Methods("GET")
    api.HandleFunc("/trending", handlers.GetTrendingSongs).Methods("GET")
    api.HandleFunc("/save", handlers.SavePlaylist).Methods("POST")

    // Serve index.html for the root path
    r.PathPrefix("/").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path == "/" {
            http.ServeFile(w, r, "static/index.html")
            return
        }
        http.NotFound(w, r)
    })

    port := os.Getenv("PORT")
    if port == "" {
        port = "3090"  // Using your current port
    }

    fmt.Printf("Server running on port %s...\n", port)
    log.Fatal(http.ListenAndServe(":"+port, r))
}